<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法小书 | MisterRabbit's Blog</title><meta name="author" content="MisterRabbit"><meta name="copyright" content="MisterRabbit"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本书是 The Little Book of Algorithms 的中文翻译版本。 目录 译者的话 关于本书 第一章 第二章 第三章 第四章 第五章 第六章 第七章 第八章 第九章 第十章 速查表 计划书">
<meta property="og:type" content="article">
<meta property="og:title" content="算法小书">
<meta property="og:url" content="http://misterrabbit0w0.github.io/2026/02/24/algorithms/index/index.html">
<meta property="og:site_name" content="MisterRabbit&#39;s Blog">
<meta property="og:description" content="本书是 The Little Book of Algorithms 的中文翻译版本。 目录 译者的话 关于本书 第一章 第二章 第三章 第四章 第五章 第六章 第七章 第八章 第九章 第十章 速查表 计划书">
<meta property="og:locale">
<meta property="og:image" content="http://misterrabbit0w0.github.io/img/avatar/avatar.jpg">
<meta property="article:published_time" content="2026-02-24T16:00:00.000Z">
<meta property="article:modified_time" content="2026-02-25T08:09:22.537Z">
<meta property="article:author" content="MisterRabbit">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://misterrabbit0w0.github.io/img/avatar/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "算法小书",
  "url": "http://misterrabbit0w0.github.io/2026/02/24/algorithms/index/",
  "image": "http://misterrabbit0w0.github.io/img/avatar/avatar.jpg",
  "datePublished": "2026-02-24T16:00:00.000Z",
  "dateModified": "2026-02-25T08:09:22.537Z",
  "author": [
    {
      "@type": "Person",
      "name": "MisterRabbit",
      "url": "http://misterrabbit0w0.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon/favicon.ico"><link rel="canonical" href="http://misterrabbit0w0.github.io/2026/02/24/algorithms/index/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法小书',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/algorithms/translators-word/"><i class="fa-fw fas fa-book"></i><span> 算法小书</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/banner/default.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">MisterRabbit's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">算法小书</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/algorithms/translators-word/"><i class="fa-fw fas fa-book"></i><span> 算法小书</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">算法小书</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-24T16:00:00.000Z" title="Created 2026-02-25 00:00:00">2026-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-25T08:09:22.537Z" title="Updated 2026-02-25 16:09:22">2026-02-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>本书是 <em>The Little Book of Algorithms</em> 的中文翻译版本。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="translators-word.html">译者的话</a></li>
<li><a href="book.html">关于本书</a></li>
<li><a href="list-1.html">第一章</a></li>
<li><a href="list-2.html">第二章</a></li>
<li><a href="list-3.html">第三章</a></li>
<li><a href="list-4.html">第四章</a></li>
<li><a href="list-5.html">第五章</a></li>
<li><a href="list-6.html">第六章</a></li>
<li><a href="list-7.html">第七章</a></li>
<li><a href="list-8.html">第八章</a></li>
<li><a href="list-9.html">第九章</a></li>
<li><a href="list-10.html">第十章</a></li>
<li><a href="cheatsheet.html">速查表</a></li>
<li><a href="plan.html">计划书</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://misterrabbit0w0.github.io">MisterRabbit</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://misterrabbit0w0.github.io/2026/02/24/algorithms/index/">http://misterrabbit0w0.github.io/2026/02/24/algorithms/index/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar/avatar.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/02/24/algorithms/list-1/" title="第一章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">第一章</div></div><div class="info-2"><div class="info-item-1">第 1 章 算法基础第 1 节 什么是算法？1 欧几里得最大公约数算法欧几里得算法是数学中最古老、最优雅的算法之一。它通过反复应用一个简单的规则来计算两个整数的最大公约数（GCD）：用较大数除以较小数所得的余数替换较大数。当余数变为零时，该步骤中的较小数就是最大公约数。 我们要解决什么问题？我们想要求两个整数 $a$ 和 $b$ 的最大公约数：即能同时整除这两个数且没有余数的最大数字。 一种朴素的方法是检查从 $\min(a,b)$ 到 1 的所有数字。这需要 $O(\min(a,b))$ 步，对于大的输入来说太慢了。欧几里得的洞见给出了一种使用除法的、快得多的递归方法： $$\gcd(a, b) &#x3D;\begin{cases}a, &amp; \text{如果 } b &#x3D; 0, \\\gcd(b, a \bmod b), &amp; \text{否则。}\end{cases}$$ 工作原理（通俗解释）想象两根长度分别为 $a$ 和 $b$ 的木棍。你可以不断地用较短木棍的长度去截取较长木棍，直到其中一根能被另一根整除。最后一个非零余数的长度就是最大公约数。 步...</div></div></div></a><a class="pagination-related" href="/2026/01/19/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/02/24/algorithms/list-4/" title="第四章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-25</div><div class="info-item-2">第四章</div></div><div class="info-2"><div class="info-item-1">第四章 图算法第31节 遍历301 深度优先搜索（递归）深度优先搜索（DFS）是一种经典的图遍历算法，它在回溯之前会尽可能深入地探索图。你选择一个起始节点，沿着一条路径尽可能远地走，只有当走到死胡同时才返回。它是图算法中的“先深入探索，再考虑其他路径”。 我们要解决什么问题？DFS 帮助我们系统地访问连通分量中的每个顶点和边。它是探索图、检测环、对边进行分类以及构建更复杂算法（如拓扑排序、强连通分量和关节点检测）的基础。 我们想要的算法能够：  从起始节点探索所有可达顶点 避免重复访问节点 记录遍历顺序  示例：你有一个迷宫。DFS 就像一个探索者，选择一条路径，尽可能深入地走，只有在卡住时才返回。 它是如何工作的（通俗解释）？将 DFS 想象成一个好奇的旅行者：每当看到一条新路径，就深入探索。当无法继续前进时，就后退一步，继续探索其他路径。 我们使用递归来自然地模拟这种行为，每次递归调用代表进入一个新节点，而返回则意味着回溯。    步骤 当前节点 动作 栈（调用路径）    1 A 访问 A [A]   2 B 访问 B (A→B) [A, B]   3 D 访问 D (B→...</div></div></div></a><a class="pagination-related" href="/2026/02/24/algorithms/list-3/" title="第三章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-25</div><div class="info-item-2">第三章</div></div><div class="info-2"><div class="info-item-1">第 3 章 数据结构实战第 21 节 数组、链表、栈、队列201 动态数组扩容动态数组扩容是我们在需要时扩展存储空间，同时保持 push 操作快速的方法。其思想很简单：当数组已满时，分配一个更大的数组，复制元素，然后继续操作。如果每次扩容时将容量加倍，那么每次 push 的平均成本将保持恒定。 我们要解决什么问题？固定数组有固定的大小。实际程序并不总是能提前知道 n 的大小。我们想要一个数组，它支持在末尾进行接近常数时间的 push 操作，能够自动增长，并且保持元素在连续内存中以利于缓存。 目标：在一个可调整大小的数组上提供 push、pop、get、set 操作，并使 push 操作的摊还时间复杂度为 O(1)。 它是如何工作的？（通俗解释）维护两个数字：size（当前元素数量）和 capacity（当前容量）。  从一个较小的容量开始（例如，1 或 8）。 执行 push 时，如果 size &lt; capacity，则写入元素并增加 size。 如果 size == capacity，则分配一个容量加倍的新存储空间，复制旧元素，释放旧内存块，然后执行 push。 （可选）...</div></div></div></a><a class="pagination-related" href="/2026/02/24/algorithms/plan/" title="计划书"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-25</div><div class="info-item-2">计划书</div></div><div class="info-2"><div class="info-item-1">计划第 1 章 算法基础1. 什么是算法？   # 算法 备注    1 欧几里得最大公约数算法 已知最古老的求最大公约数的算法   2 埃拉托斯特尼筛法 高效生成素数   3 二分查找 分治搜索   4 快速幂算法 快速幂计算   5 长除法 经典的分步算术运算   6 模加法算法 循环算术   7 进制转换算法 在不同数制间转换   8 阶乘计算 递归与迭代方法   9 斐波那契数列 递归与动态计算对比   10 汉诺塔 递归问题解决模式   2. 度量时间与空间   # 算法 备注    11 操作计数 手动步数计数以分析复杂度   12 循环分析 评估循环的时间开销   13 递归展开 分析递归开销   14 摊还分析 平均每操作成本   15 空间计数 栈和堆跟踪   16 内存占用估算器 跟踪每个变量的使用情况   17 时间复杂度表 映射 O(1)…O(n²)…O(2ⁿ)   18 时空权衡 缓存与重新计算的权衡   19 性能剖析算法 经验性时间测量   20 基准测试框架 比较算法性能   3. 大 O、大 Θ、大 Ω   # 算法 备注    21 增长率比较...</div></div></div></a><a class="pagination-related" href="/2026/02/24/algorithms/list-1/" title="第一章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-25</div><div class="info-item-2">第一章</div></div><div class="info-2"><div class="info-item-1">第 1 章 算法基础第 1 节 什么是算法？1 欧几里得最大公约数算法欧几里得算法是数学中最古老、最优雅的算法之一。它通过反复应用一个简单的规则来计算两个整数的最大公约数（GCD）：用较大数除以较小数所得的余数替换较大数。当余数变为零时，该步骤中的较小数就是最大公约数。 我们要解决什么问题？我们想要求两个整数 $a$ 和 $b$ 的最大公约数：即能同时整除这两个数且没有余数的最大数字。 一种朴素的方法是检查从 $\min(a,b)$ 到 1 的所有数字。这需要 $O(\min(a,b))$ 步，对于大的输入来说太慢了。欧几里得的洞见给出了一种使用除法的、快得多的递归方法： $$\gcd(a, b) &#x3D;\begin{cases}a, &amp; \text{如果 } b &#x3D; 0, \\\gcd(b, a \bmod b), &amp; \text{否则。}\end{cases}$$ 工作原理（通俗解释）想象两根长度分别为 $a$ 和 $b$ 的木棍。你可以不断地用较短木棍的长度去截取较长木棍，直到其中一根能被另一根整除。最后一个非零余数的长度就是最大公约数。 步...</div></div></div></a><a class="pagination-related" href="/2026/02/24/algorithms/list-2/" title="第二章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-25</div><div class="info-item-2">第二章</div></div><div class="info-2"><div class="info-item-1">第 2 章 排序与搜索第 11 节 基础排序101 冒泡排序冒泡排序就像逐个清洗盘子，你不断把最大的盘子移到最下面，直到所有东西都干净且有序。它简单、直观，非常适合在深入学习更高级的方法之前建立你的排序直觉。 我们要解决什么问题？我们希望通过重复比较和交换顺序错误的相邻项，来将一系列元素按顺序（升序或降序）排列。 正式定义：给定一个数组 A[0…n-1]，重复进行遍历，直到没有交换发生。每次遍历都会将剩余元素中最大的一个“冒泡”到其最终位置。 示例   步骤 数组状态 描述    0 [5, 3, 4, 1] 初始数组   1 [3, 4, 1, 5] 5 冒泡到末尾   2 [3, 1, 4, 5] 4 冒泡到位置 3   3 [1, 3, 4, 5] 数组完全排序   它是如何工作的（通俗解释）？想象气泡上升到水面，最大的气泡最先到达顶部。在冒泡排序中，每次遍历列表都会比较相邻的元素对，如果它们的顺序错误就交换它们。每次完整的遍历之后，就会有一个元素被放置到正确的位置。 我们重复这个过程，直到某次遍历没有发生任何交换，这意味着数组已经排序好了。 逐步过程   步骤 动作 结果...</div></div></div></a><a class="pagination-related" href="/2026/02/24/algorithms/book/" title="关于本书"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-25</div><div class="info-item-2">关于本书</div></div><div class="info-2"><div class="info-item-1">本书 下载 PDF - 适合打印 下载 EPUB - 适合电子阅读器 查看 LaTex - .tex 源文件 源代码 (Github) - Markdown 源文件 在 GitHub Pages 上阅读 - 在线查看  遵循 CC BY-NC-SA 4.0 许可协议。 第 1 章 算法基础1. 什么是算法？让我们从头开始。在代码、数据或性能之前，我们需要清楚地了解算法究竟是什么。 算法是一个清晰、按部就班地解决问题的过程。可以把它想象成一个食谱：你有输入（食材）、一系列步骤（说明）和一个输出（完成的菜肴）。 算法的核心应该是：  精确的：每个步骤都有明确的定义，没有歧义。 有限的：在有限的步骤之后结束。 有效的：每个步骤都足够简单，可以执行。 确定的（通常）：相同的输入产生相同的输出。  当你编写算法时，你是在描述如何从问题得到答案，而不仅仅是答案是什么。 示例：求 1 到 (n) 的和假设你想求从 1 到 (n) 的数字之和。 自然语言步骤  设置 total = 0 对于每个从 1 到 n 的 i，将 i 加到 total 上 返回 total  伪代码 12345算法 Su...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">MisterRabbit</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MisterRabbit0w0"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/24/algorithms/index/" title="算法小书">算法小书</a><time datetime="2026-02-24T16:00:00.000Z" title="Created 2026-02-25 00:00:00">2026-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/24/algorithms/list-1/" title="第一章">第一章</a><time datetime="2026-02-24T16:00:00.000Z" title="Created 2026-02-25 00:00:00">2026-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/24/algorithms/list-4/" title="第四章">第四章</a><time datetime="2026-02-24T16:00:00.000Z" title="Created 2026-02-25 00:00:00">2026-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/24/algorithms/list-5/" title="第五章">第五章</a><time datetime="2026-02-24T16:00:00.000Z" title="Created 2026-02-25 00:00:00">2026-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/24/algorithms/list-7/" title="第七章">第七章</a><time datetime="2026-02-24T16:00:00.000Z" title="Created 2026-02-25 00:00:00">2026-02-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2026 By MisterRabbit</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.1.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>